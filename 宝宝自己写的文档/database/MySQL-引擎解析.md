## MySQL-引擎解析

### 一、存储引擎的了解，为什么要选择存储引擎？

MySQL中的数据用各种不同的技术存储在文件或者内存中。这些技术都使用了不同的存储机制，索引技巧，与锁定水平。通过选择不同的技术你就能获得不同的查询速度，与其他的功能。

mysql中配置了很多这样的存储引擎可以根据项目的类型选择相对应的存储引擎。

#### **定义：**

 数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足业务需求。这使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（索引、视图和存储过程）。

#### **作用：**

1. 设计并创建数据库以保存系统的关系或xml文档
2. 实现系统以访问和更改数据库中所存储的数据。
3. 为单位或客户部署实现的系统。
4. 提供日常支持以优化数据库性能。

#### **存储引擎主要有：** 

1. MyIsam(常用)
2. InnoDB（常用）
3. Memory
4. Blackhole
5. CSV
6. Performance_Schema
7. Archive
8. Federated
9. Mrg_Myisam

#### **如何修改数据库引擎：**

1）修改配置文件my.ini

将mysql.ini另存为my.ini，在[mysqld]后面添加default-storage-engine=InnoDB，重启服务，数据库默认的引擎修改为InnoDB

2)建表时指定

```mysql
create table table_name( 
    id int(10) primary key,
    name varchar(50)
    )type=MyISAM;
```

3）建表后更改

```mysql
alter table table_name type=InnoDB
```

4）查看数据库默认存储引擎

```mysql
show variables like '%engine%'
```





### 二、InnoDB（V5.1之后默认存储引擎）

#### **定义：**

**InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。**

Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。

#### **适用场景：**

1. **经常更新的表，适合处理多重并发的更新请求。**
2. **支持事务。**
3. **可以从灾难中恢复（通过bin-log日志等）。**
4. **外键约束。只有他支持外键。**
5. **支持自动增加列属性auto_increment。**

#### **官方介绍：**

1. **InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。**
2. **InnoDB锁定在行级并且也在SELECT语句提供一个Oracle风格一致的非锁定读，这些特色增加了多用户部署和性能。没有在InnoDB中扩大锁定的需要，因为在InnoDB中行级锁定适合非常小的空间。**
3. **InnoDB也支持FOREIGN KEY强制。在SQL查询中，你可以自由地将InnoDB类型的表与其它MySQL的表的类型混合起来，甚至在同一个查询中也可以混合。**
4. **InnoDB是为处理巨大数据量时的最大性能设计，它的CPU效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的。**
5. **InnoDB被用来在众多需要高性能的大型数据库站点上产生。**

### 三、MyIsam（V5.1之前的默认存储引擎）

#### **定义：**

**MyIASM是MySQL V5.1之前默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。**

**MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。**

意味着：引擎在创建表的时候，会创建三个文件，一个是.frm文件用于存储表的定义，一个是.MYD文件用于存储表的数据，另一个是.MYI文件，存储的是索引。操作系统对大文件的操作是比较慢的，这样将表分为三个文件，那么.MYD这个文件单独来存放数据自然可以优化数据库的查询等操作。**有索引管理和字段管理**。MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。

#### **适用场景**：

1. 不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。
2. 不支持外键的表设计。
3. 查询速度很快，如果数据库insert和update的操作比较多的话比较适用。
4. 整天 对表进行加锁的场景。
5. MyISAM极度强调快速读取操作。
6. MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

#### **缺点：**

**就是不能在表损坏后恢复数据。（是不能主动恢复）**



### 四、MyIsam与InnoDB对比

#### 1）**事务**。

**MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。**

InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如updatetable set num=1 where name like “a%”

就是说在不确定的范围时，InnoDB还是会锁表的。

#### 2）性能

MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。

#### 3）行数保存

InnoDB 中不保存表的具体行数，也就是说，执行 `select count(*) from table`时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时，两种表的操作是一样的。

#### 4）索引存储

**对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。**

**MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持**

MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。

InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。

#### 5）服务器数据备份

**InnoDB必须导出SQL来备份**，`LOAD TABLE FROM MASTER`操作对InnoDB是不起作用的，**解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。**

而且MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。

**InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。**

#### 6）锁的支持

**MyISAM只支持表锁**。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。**但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的**

#### 7）表引擎的选择

**以下两点必须使用 InnoDB：**

1）**可靠性高或者要求事务处理**，则使用InnoDB。这个是必须的。

2）**表更新和查询都相当的频繁**，并且**表锁定的机会比较大**的情况指定InnoDB数据引擎的创建。

**对比之下，MyISAM的使用场景：**

1）**做很多count的计算的**。如一些日志，调查的业务表。

2）**插入修改不频繁，查询非常频繁的**。

**MySQL能够允许你在表这一层应用数据库引擎，所以你可以只对需要事务处理的表格来进行性能优化，而把不需要事务处理的表格交给更加轻便的MyISAM引擎。对于 MySQL而言，灵活性才是关键。**

